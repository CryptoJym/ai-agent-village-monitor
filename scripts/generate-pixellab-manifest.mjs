#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';
import process from 'node:process';

const __dirname = path.dirname(new URL(import.meta.url).pathname);
const FRONTEND_ROOT = path.resolve(__dirname, '..', 'packages', 'frontend');
const PUBLIC_ROOT = path.join(FRONTEND_ROOT, 'public', 'assets');
const OUTPUT_PATH = path.join(FRONTEND_ROOT, 'src', 'assets', 'pixellabMetadata.ts');

const SUPPORTED_ANIMATION_CATEGORIES = ['agents', 'emotes', 'bug-bots', 'houses'];
const TILES_ROOT = path.join(PUBLIC_ROOT, 'tiles');

async function pathExists(targetPath) {
  try {
    await fs.access(targetPath);
    return true;
  } catch {
    return false;
  }
}

async function readJson(filePath) {
  try {
    const raw = await fs.readFile(filePath, 'utf8');
    return JSON.parse(raw);
  } catch (err) {
    if (process.env.DEBUG_PIXELLAB_MANIFEST === 'true') {
      console.warn(`Failed to read ${filePath}:`, err);
    }
    return null;
  }
}

async function collectCategory(category) {
  const baseDir = path.join(PUBLIC_ROOT, category);
  let entries = [];
  try {
    entries = await fs.readdir(baseDir, { withFileTypes: true });
  } catch (err) {
    if (process.env.DEBUG_PIXELLAB_MANIFEST === 'true') {
      console.warn(`Skipping category ${category}:`, err);
    }
    return {};
  }

  const result = {};
  for (const entry of entries) {
    if (!entry.isDirectory()) continue;
    const key = entry.name;
    const metadataPath = path.join(baseDir, key, 'metadata.json');
    const metadata = await readJson(metadataPath);
    if (!metadata?.frames?.animations) continue;
    const animations = metadata.frames.animations;
    const cleaned = {};
    for (const [animationName, directions] of Object.entries(animations)) {
      const directionCounts = {};
      for (const [direction, frames] of Object.entries(directions ?? {})) {
        directionCounts[direction] = Array.isArray(frames) ? frames.length : 0;
      }
      cleaned[animationName] = directionCounts;
    }
    result[key] = cleaned;
  }
  return result;
}

async function collectTiles() {
  const result = {};
  if (!(await pathExists(TILES_ROOT))) {
    return result;
  }
  const categories = await fs.readdir(TILES_ROOT, { withFileTypes: true });
  for (const category of categories) {
    if (!category.isDirectory()) continue;
    const categoryKey = category.name;
    const categoryPath = path.join(TILES_ROOT, categoryKey);
    const entries = await fs.readdir(categoryPath, { withFileTypes: true });
    result[categoryKey] = {};
    for (const entry of entries) {
      if (!entry.isDirectory()) continue;
      const entryKey = entry.name;
      const metadataPath = path.join(categoryPath, entryKey, 'metadata.json');
      if (!(await pathExists(metadataPath))) continue;
      try {
        const raw = await fs.readFile(metadataPath, 'utf8');
        result[categoryKey][entryKey] = JSON.parse(raw);
      } catch (err) {
        if (process.env.DEBUG_PIXELLAB_MANIFEST === 'true') {
          console.warn(`Failed to parse tile metadata for ${categoryKey}/${entryKey}:`, err);
        }
      }
    }
  }
  return result;
}

async function buildManifest() {
  const animationManifest = {};
  for (const category of SUPPORTED_ANIMATION_CATEGORIES) {
    animationManifest[category] = await collectCategory(category);
  }
  const tileManifest = await collectTiles();
  const fileContents = `// AUTO-GENERATED by scripts/generate-pixellab-manifest.mjs\n// Do not edit manually.\n\nexport const pixellabAnimationMetadata = ${JSON.stringify(
    animationManifest,
    null,
    2,
  )} as const;\n\nexport type PixellabAnimationMetadata = typeof pixellabAnimationMetadata;\n\nexport const pixellabTileMetadata = ${JSON.stringify(tileManifest, null, 2)} as const;\n\nexport type PixellabTileMetadata = typeof pixellabTileMetadata;\n`;

  await fs.mkdir(path.dirname(OUTPUT_PATH), { recursive: true });
  await fs.writeFile(OUTPUT_PATH, fileContents, 'utf8');
}

(async () => {
  try {
    await buildManifest();
    process.exit(0);
  } catch (error) {
    console.error('Failed to generate pixellab metadata:', error);
    process.exit(1);
  }
})();
